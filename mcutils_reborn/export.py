import os
import beet

from . import Namespace
from .paths import *
from .commands import LiteralCommand


class Datapack(Namespace):
    def __init__(self, name: str,
                 path: str = ".",
                 description: str = "A Datapack generated by the mcutils_reborn module.",
                 pack_format: int = -2):
        super().__init__(name)

        self.path_ = path
        self.description = description
        self.pack_format = pack_format

    def path(self):
        return []

    def export(self) -> beet.DataPack:
        all_mcfuncs = self.get_all_mcfunctions()

        out = beet.DataPack(
            name=self.name,
            path=os.path.join(self.path_, self.name),
            zipped=False,
            description=self.description,
            pack_format=self.pack_format,
        )

        unique_strings = {}
        existing_strings = set()
        for mcfunc in all_mcfuncs.values():
            for command in mcfunc.commands:
                for unique_string in command.get_unique_strings():
                    if unique_string in unique_strings:
                        continue

                    new_string = unique_string.get(existing_strings, mcfunc)
                    unique_strings[unique_string] = new_string
                    existing_strings.add(new_string)

                    print(f" * {unique_string} -> {new_string!r}")

        for path, mcfunc in all_mcfuncs.items():
            print(f"-> {path_to_str(path)}")

            mcfunc.commands = [
                LiteralCommand(f"#> {path_to_str(path)}"),
                LiteralCommand("#"),
                *(LiteralCommand(f"# {paragraph}") for paragraph in mcfunc.description.splitlines()),
                *mcfunc.commands
            ]

            content = mcfunc.content(lambda mcfunc_: path_to_str(mcfunc_.path()), unique_strings)

            # noinspection PyTypeChecker
            out[path_to_str(path)] = beet.Function(content)

        return out
