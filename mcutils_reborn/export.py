import os
import beet

from . import Namespace, FunctionTag, Pathable
from .paths import *
from .commands import LiteralCommand, UniqueString, Command, NonUniqueString
from .exceptions import CompilationError


class Datapack(Namespace):
    def __init__(self, name: str,
                 path: str = ".",
                 description: str = "A Datapack generated by the mcutils_reborn module.",
                 pack_format: int = -2):
        super().__init__(name)

        self.path_ = path
        self.description = description
        self.pack_format = pack_format

    def path(self):
        return []

    def export(self) -> beet.DataPack:
        all_mcfuncs = self.get_all_mcfunctions()

        out = beet.DataPack(
            name=self.name,
            path=os.path.join(self.path_, self.name),
            zipped=False,
            description=self.description,
            pack_format=self.pack_format,
        )

        # set the namespace of all unique strings
        for mcfunc in all_mcfuncs.values():
            for command in mcfunc.commands:
                for unique_string in command.get_unique_strings():
                    if unique_string.namespace is None:
                        unique_string.namespace = mcfunc

        # resolve all unique strings
        def path_of_func(pathable: Pathable) -> str:
            return ("#" if isinstance(pathable, FunctionTag) else "") + path_to_str(pathable.path())

        unique_strings: dict[UniqueString, str] = {}
        existing_strings: set[str] = set()

        # noinspection PyShadowingNames
        def resolve(unique_string: UniqueString) -> str:
            if unique_string not in unique_strings:
                unique_strings[unique_string] = unique_string.get(existing_strings, resolve, path_of_func)
                existing_strings.add(unique_strings[unique_string])

            return unique_strings[unique_string]

        for mcfunc in all_mcfuncs.values():
            for command in mcfunc.commands:
                for unique_string in command.get_unique_strings():
                    resolve(unique_string)

        _max_name_len = max(len(s.__class__.__name__) for s in unique_strings)
        _max_args_len = max(len(repr(s.value)) for s in unique_strings)

        for unique_string, string in unique_strings.items():
            if isinstance(unique_string, NonUniqueString):
                continue

            print(f" * {unique_string.__class__.__name__: <{_max_name_len}} "
                  f"{unique_string.value!r: <{_max_args_len}} "
                  f"-> {string!r}")

        def get_mcfunc_content(commands: list[Command],
                               strings: dict["UniqueString", str]) -> list[str]:
            return [cmd.get_str(path_of_func, strings) for cmd in commands]

        for path, mcfunc in all_mcfuncs.items():
            print(f"-> {path_to_str(path)}")

            tags = [path_to_str(tag.path()) if isinstance(tag, FunctionTag) else tag for tag in mcfunc.tags]

            handles_comment = []
            if tags:
                handles_comment += [
                    LiteralCommand("#"),
                    LiteralCommand("# @handles"),
                    *[LiteralCommand(f"#   #{handler}") for handler in tags]
                ]

            description_comment = []
            if mcfunc.description:
                description_comment += [
                    LiteralCommand("#"),
                    *[LiteralCommand(f"# {paragraph}") for paragraph in mcfunc.description.splitlines()]
                ]

            commands = [
                LiteralCommand(f"#> {path_to_str(path)}"),
                *description_comment,
                *handles_comment,
                *mcfunc.commands
            ]

            try:
                content = get_mcfunc_content(commands, unique_strings)
            except CompilationError as e:
                raise CompilationError(f"Error getting command string in function {path_to_str(mcfunc.path())}") from e

            # noinspection PyTypeChecker
            out[path_to_str(path)] = beet.Function(content, tags=tags)

        # set replace=false in all function tags
        for tag in out.function_tags.values():
            tag.data["replace"] = False

        return out


path_of_func_callable = typing.Callable[[Pathable], str]
resolve_callable = typing.Callable[[UniqueString | str], str]
