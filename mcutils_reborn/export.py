import os
import beet

from . import Namespace, FunctionTag, MCFunction
from .paths import *
from .commands import LiteralCommand, UniqueString, Command


class Datapack(Namespace):
    def __init__(self, name: str,
                 path: str = ".",
                 description: str = "A Datapack generated by the mcutils_reborn module.",
                 pack_format: int = -2):
        super().__init__(name)

        self.path_ = path
        self.description = description
        self.pack_format = pack_format

    def path(self):
        return []

    def export(self) -> beet.DataPack:
        all_mcfuncs = self.get_all_mcfunctions()

        out = beet.DataPack(
            name=self.name,
            path=os.path.join(self.path_, self.name),
            zipped=False,
            description=self.description,
            pack_format=self.pack_format,
        )

        # set the namespace of all unique strings
        for mcfunc in all_mcfuncs.values():
            for command in mcfunc.commands:
                for unique_string in command.get_unique_strings():
                    if unique_string.namespace is None:
                        unique_string.namespace = mcfunc

        unique_strings = {}
        existing_strings = set()

        # noinspection PyShadowingNames
        def resolve(unique_string: UniqueString) -> str:
            if unique_string not in unique_strings:
                unique_strings[unique_string] = unique_string.get(existing_strings, resolve)
                existing_strings.add(unique_strings[unique_string])

            return unique_strings[unique_string]

        for mcfunc in all_mcfuncs.values():
            for command in mcfunc.commands:
                for unique_string in command.get_unique_strings():
                    resolve(unique_string)

        for unique_string, string in unique_strings.items():
            print(f" * {unique_string} -> {string!r}")

        def get_mcfunc_content(commands: list[Command],
                               path_of_func: typing.Callable[["MCFunction"], str],
                               strings: dict["UniqueString", str]) -> list[str]:
            return [cmd.get_str(path_of_func, strings) for cmd in commands]

        for path, mcfunc in all_mcfuncs.items():
            print(f"-> {path_to_str(path)}")

            tags = [path_to_str(tag.path()) if isinstance(tag, FunctionTag) else tag for tag in mcfunc.tags]

            handles_comment = []
            if tags:
                handles_comment += [
                    LiteralCommand("#"),
                    LiteralCommand("# @handles"),
                    *[LiteralCommand(f"#   #{handler}") for handler in tags]
                ]

            description_comment = []
            if mcfunc.description:
                description_comment += [
                    LiteralCommand("#"),
                    *[LiteralCommand(f"# {paragraph}") for paragraph in mcfunc.description.splitlines()]
                ]

            commands = [
                LiteralCommand(f"#> {path_to_str(path)}"),
                *description_comment,
                *handles_comment,
                *mcfunc.commands
            ]

            content = get_mcfunc_content(
                commands,

                lambda pathable:
                ("#" if isinstance(pathable, FunctionTag) else "") + path_to_str(pathable.path()),

                unique_strings
            )

            # noinspection PyTypeChecker
            out[path_to_str(path)] = beet.Function(content, tags=tags)

        return out
